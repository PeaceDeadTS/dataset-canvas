---
description: React coding standards and best practices for the Dataset Canvas application
globs: "**/*.jsx,**/*.tsx"
---

# React Best Practices

## Project Structure
- The frontend application code lives in the `src` directory.
- The backend application code lives in the `backend` directory.
- Follow a standard directory structure:
  - `components/`: Reusable UI components
  - `pages/`: Top-level page components
  - `lib/`: Utility functions
  - `hooks/`: Custom React hooks
  - `assets/`: Static assets

## Component Structure
- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript
- Split large components into smaller, focused ones
- Follow a consistent file organization pattern:
  ```
  component-name/
    component-name.tsx
    component-name.module.scss
    component-name.test.tsx
    index.ts
  ```

## Hooks
- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Avoid useEffect unless absolutely required
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management
- Use `useState` for local component state.
- For complex global state, consider libraries like Zustand or Redux Toolkit, but start with simpler solutions like React Context when appropriate.
- Keep state as close to where it's used as possible to avoid unnecessary re-renders.
- Avoid prop drilling through proper state management.

## Performance
- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Tooling
- Use Biome for code linting and formatting
- Follow CSS/SCSS linting rules defined in .stylelintrc.json
- Use TypeScript for type safety
- Keep bundle size in check by monitoring imports

## Forms
- Use controlled components for form inputs
- Implement proper form validation
- Handle form submission states properly
- Show appropriate loading and error states
- Use form libraries for complex forms
- Implement proper accessibility for forms

## Error Handling
- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Testing
- Write unit tests for components
- Implement integration tests for complex flows
- Use React Testing Library
- Test user interactions
- Test error scenarios
- Implement proper mock data

## Accessibility
- Ensure components meet WCAG 2.1 AA standards
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

## Code Organization
- Use kebab-case for file names (e.g., `list-item.tsx`).
- Prefer one component per file. Group related components in the same folder.
- Co-locate component-specific assets (like CSS modules or tests) with the component file.
- Implement a clear and consistent directory structure.

## Best Practices
- Avoid cyclic imports.
- Use proper imports/exports (`index.ts` barrels can be useful but use them judiciously).
- Follow established import ordering (e.g., React, external libraries, internal components, assets).
- Compose components rather than extending them.
- Keep components focused on a single responsibility.
- Document complex logic with clear comments.
- Follow the project's folder structure and naming conventions.
- Prefer controlled components over uncontrolled ones 